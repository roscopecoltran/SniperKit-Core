# Collections

`CMake` is missing a lot of helper functions when it comes to collections. 
However using the `list` function that `CMake` provides it is possible to add alot of functions that help the developer.




### Function List


* [encoded_list](#encoded_list)
* [encoded_list_append](#encoded_list_append)
* [encoded_list_decode](#encoded_list_decode)
* [encoded_list_get](#encoded_list_get)
* [encoded_list_peek_back](#encoded_list_peek_back)
* [encoded_list_peek_front](#encoded_list_peek_front)
* [encoded_list_pop_back](#encoded_list_pop_back)
* [encoded_list_pop_front](#encoded_list_pop_front)
* [encoded_list_remove_at](#encoded_list_remove_at)
* [encoded_list_remove_item](#encoded_list_remove_item)
* [encoded_list_set](#encoded_list_set)
* [encoded_list_to_cmake_string](#encoded_list_to_cmake_string)
* [is_encoded_list](#is_encoded_list)
* [index_range](#index_range)
* [linked_list_insert_after](#linked_list_insert_after)
* [linked_list_insert_before](#linked_list_insert_before)
* [linked_list_new](#linked_list_new)
* [linked_list_node_new](#linked_list_node_new)
* [linked_list_peek_back](#linked_list_peek_back)
* [linked_list_peek_front](#linked_list_peek_front)
* [linked_list_pop_back](#linked_list_pop_back)
* [linked_list_pop_front](#linked_list_pop_front)
* [linked_list_push_back](#linked_list_push_back)
* [linked_list_push_front](#linked_list_push_front)
* [linked_list_remove](#linked_list_remove)
* [linked_list_replace](#linked_list_replace)
* [list_after](#list_after)
* [list_all](#list_all)
* [list_any](#list_any)
* [list_at](#list_at)
* [list_before](#list_before)
* [list_check_items](#list_check_items)
* [list_combinations](#list_combinations)
* [list_contains](#list_contains)
* [list_contains_any](#list_contains_any)
* [list_count](#list_count)
* [list_equal](#list_equal)
* [list_erase](#list_erase)
* [list_erase_slice](#list_erase_slice)
* [list_except](#list_except)
* [list_extract](#list_extract)
* [list_extract_any_flag](#list_extract_any_flag)
* [list_extract_any_labelled_value](#list_extract_any_labelled_value)
* [list_extract_flag](#list_extract_flag)
* [list_extract_flags](#list_extract_flags)
* [list_extract_flag_name](#list_extract_flag_name)
* [list_extract_labelled_keyvalue](#list_extract_labelled_keyvalue)
* [list_extract_labelled_value](#list_extract_labelled_value)
* [list_extract_matches](#list_extract_matches)
* [list_find](#list_find)
* [list_find_any](#list_find_any)
* [list_find_flags](#list_find_flags)
* [list_fold](#list_fold)
* [list_get](#list_get)
* [list_get_labelled_value](#list_get_labelled_value)
* [list_get_lean](#list_get_lean)
* [list_intersect](#list_intersect)
* [list_intersect_args](#list_intersect_args)
* [list_isempty](#list_isempty)
* [list_isinorder](#list_isinorder)
* [list_iterator](#list_iterator)
* [list_iterator_break](#list_iterator_break)
* [list_iterator_next](#list_iterator_next)
* [list_length](#list_length)
* [list_max](#list_max)
* [list_modify](#list_modify)
* [list_normalize_index](#list_normalize_index)
* [list_parse_descriptor](#list_parse_descriptor)
* [list_peek_back](#list_peek_back)
* [list_peek_front](#list_peek_front)
* [list_pop_back](#list_pop_back)
* [list_pop_front](#list_pop_front)
* [list_push_back](#list_push_back)
* [list_push_front](#list_push_front)
* [list_regex_match](#list_regex_match)
* [list_regex_match_ignore](#list_regex_match_ignore)
* [list_remove](#list_remove)
* [list_remove_at](#list_remove_at)
* [list_remove_duplicates](#list_remove_duplicates)
* [list_replace_at](#list_replace_at)
* [list_replace_slice](#list_replace_slice)
* [list_reverse](#list_reverse)
* [list_select](#list_select)
* [list_select_property](#list_select_property)
* [list_set_at](#list_set_at)
* [list_slice](#list_slice)
* [list_sort](#list_sort)
* [list_split](#list_split)
* [list_split_at](#list_split_at)
* [list_swap](#list_swap)
* [list_to_map](#list_to_map)
* [list_to_string](#list_to_string)
* [list_union](#list_union)
* [list_unique](#list_unique)
* [list_where](#list_where)
* [list_without_range](#list_without_range)
* [is_range](#is_range)
* [list_range_get](#list_range_get)
* [list_range_indices](#list_range_indices)
* [list_range_partial_write](#list_range_partial_write)
* [list_range_remove](#list_range_remove)
* [list_range_replace](#list_range_replace)
* [list_range_set](#list_range_set)
* [list_range_try_get](#list_range_try_get)
* [range_from_indices](#range_from_indices)
* [range_indices](#range_indices)
* [range_indices_valid](#range_indices_valid)
* [range_instanciate](#range_instanciate)
* [range_parse](#range_parse)
* [range_partial_unpack](#range_partial_unpack)
* [range_simplify](#range_simplify)
* [set_difference](#set_difference)
* [set_isequal](#set_isequal)
* [set_issubset](#set_issubset)
* [structured_list_parse](#structured_list_parse)
* [list_structure_print_help](#list_structure_print_help) 

### Function Descriptions

## <a name="encoded_list"></a> `encoded_list`





## <a name="encoded_list_append"></a> `encoded_list_append`





## <a name="encoded_list_decode"></a> `encoded_list_decode`





## <a name="encoded_list_get"></a> `encoded_list_get`





## <a name="encoded_list_peek_back"></a> `encoded_list_peek_back`





## <a name="encoded_list_peek_front"></a> `encoded_list_peek_front`





## <a name="encoded_list_pop_back"></a> `encoded_list_pop_back`





## <a name="encoded_list_pop_front"></a> `encoded_list_pop_front`





## <a name="encoded_list_remove_at"></a> `encoded_list_remove_at`





## <a name="encoded_list_remove_item"></a> `encoded_list_remove_item`





## <a name="encoded_list_set"></a> `encoded_list_set`





## <a name="encoded_list_to_cmake_string"></a> `encoded_list_to_cmake_string`





## <a name="is_encoded_list"></a> `is_encoded_list`





## <a name="index_range"></a> `index_range`





## <a name="linked_list_insert_after"></a> `linked_list_insert_after`





## <a name="linked_list_insert_before"></a> `linked_list_insert_before`





## <a name="linked_list_new"></a> `linked_list_new`





## <a name="linked_list_node_new"></a> `linked_list_node_new`





## <a name="linked_list_peek_back"></a> `linked_list_peek_back`





## <a name="linked_list_peek_front"></a> `linked_list_peek_front`





## <a name="linked_list_pop_back"></a> `linked_list_pop_back`





## <a name="linked_list_pop_front"></a> `linked_list_pop_front`





## <a name="linked_list_push_back"></a> `linked_list_push_back`





## <a name="linked_list_push_front"></a> `linked_list_push_front`





## <a name="linked_list_remove"></a> `linked_list_remove`





## <a name="linked_list_replace"></a> `linked_list_replace`





## <a name="list_after"></a> `list_after`





## <a name="list_all"></a> `list_all`





## <a name="list_any"></a> `list_any`





## <a name="list_at"></a> `list_at`





## <a name="list_before"></a> `list_before`





## <a name="list_check_items"></a> `list_check_items`





## <a name="list_combinations"></a> `list_combinations`





## <a name="list_contains"></a> `list_contains`





## <a name="list_contains_any"></a> `list_contains_any`





## <a name="list_count"></a> `list_count`





## <a name="list_equal"></a> `list_equal`

 comapres two lists with each other
 usage
 list_equal( 1 2 3 4 1 2 3 4)
 list_equal( listA listB)
 list_equal( ${listA} ${listB})
 ...
 COMPARATOR defaults to STREQUAL
 COMPARATOR can also be a lambda expression
 COMPARATOR can also be EQUAL




## <a name="list_erase"></a> `list_erase`

 removes the specified range from lst the start_index is inclusive and end_index is exclusive





## <a name="list_erase_slice"></a> `list_erase_slice`

 removes the specified range from lst and returns the removed elements




## <a name="list_except"></a> `list_except`

 return those elemnents of minuend that are not in subtrahend




## <a name="list_extract"></a> `list_extract`

 extracts elements from the list
 example
 set(lst 1 2  )
 list_extract(lst a b c)
 a contains 1
 b contains 2
 c contains nothing
 returns the rest of list




## <a name="list_extract_any_flag"></a> `list_extract_any_flag`

 extracts all of the specified flags and returns true if any of them were found




## <a name="list_extract_any_labelled_value"></a> `list_extract_any_labelled_value`





## <a name="list_extract_flag"></a> `list_extract_flag`

extracts a single flag from a list returning true if it was found
 false otherwise. 
 if flag exists multiple time online the first instance of the flag is removed
 from the list




## <a name="list_extract_flags"></a> `list_extract_flags`

 extracts all flags specified and returns a map with the key being the flag name if it was found and the value being set to tru
 e.g. list_extract_flags([a,b,c,d] a c e) -> {a:true,c:true}, [b,d]




## <a name="list_extract_flag_name"></a> `list_extract_flag_name`





## <a name="list_extract_labelled_keyvalue"></a> `list_extract_labelled_keyvalue`





## <a name="list_extract_labelled_value"></a> `list_extract_labelled_value`

 searchs for label in lst. if label is found 
 the label and its following value is removed
 and returned
 if label is found but no value follows ${ARGN} is returned
 if following value is enclosed in [] the brackets are removed
 this allows mulitple values to be returned ie
 list_extract_labelled_value(lstA --test1)
 if lstA is a;b;c;--test1;[1;3;4];d
 the function returns 1;3;4




## <a name="list_extract_matches"></a> `list_extract_matches`





## <a name="list_find"></a> `list_find`

 searchs lst for value and returns the first idx found
 returns -1 if value is not found




## <a name="list_find_any"></a> `list_find_any`





## <a name="list_find_flags"></a> `list_find_flags`





## <a name="list_fold"></a> `list_fold`

 folds the specified list into a single result by recursively applying the aggregator




## <a name="list_get"></a> `list_get`





## <a name="list_get_labelled_value"></a> `list_get_labelled_value`





## <a name="list_get_lean"></a> `list_get_lean`





## <a name="list_intersect"></a> `list_intersect`

 returns a list containing all elemmtns contained
 in all passed list references




## <a name="list_intersect_args"></a> `list_intersect_args`

 returns only those flags which are contained in list and in the varargs
 ie list = [--a --b --c --d]
 list_intersect_args(list --c --d --e) ->  [--c --d]




## <a name="list_isempty"></a> `list_isempty`

 checks if the given list reference is an empty list




## <a name="list_isinorder"></a> `list_isinorder`

 returns true if value ${a} comes before value ${b} in list __list_isinorder_lst
 sets ${result} to true or false




## <a name="list_iterator"></a> `list_iterator`





## <a name="list_iterator_break"></a> `list_iterator_break`





## <a name="list_iterator_next"></a> `list_iterator_next`





## <a name="list_length"></a> `list_length`





## <a name="list_max"></a> `list_max`





## <a name="list_modify"></a> `list_modify`





## <a name="list_normalize_index"></a> `list_normalize_index`

 returns the normalized index.  negative indices are transformed to i => length - i
 if the index is out of range after transformation -1 is returned and a warnign is issued
 note: index evaluating to length are valid (one behind last)




## <a name="list_parse_descriptor"></a> `list_parse_descriptor`

 returns true if value could be parsed




## <a name="list_peek_back"></a> `list_peek_back`





## <a name="list_peek_front"></a> `list_peek_front`

 gets the first element of the list without modififying it




## <a name="list_pop_back"></a> `list_pop_back`

 removes the last element from list and returns it




## <a name="list_pop_front"></a> `list_pop_front`

 removes the first value of the list and returns it




## <a name="list_push_back"></a> `list_push_back`

 adds a value to the end of the list




## <a name="list_push_front"></a> `list_push_front`

 adds a value at the beginning of the list




## <a name="list_regex_match"></a> `list_regex_match`





## <a name="list_regex_match_ignore"></a> `list_regex_match_ignore`





## <a name="list_remove"></a> `list_remove`

 removes all items specified in varargs from list
 returns the number of items removed




## <a name="list_remove_at"></a> `list_remove_at`

 removes all items at all specified indices from list 




## <a name="list_remove_duplicates"></a> `list_remove_duplicates`





## <a name="list_replace_at"></a> `list_replace_at`

 replaces lists  value at i with new_value




## <a name="list_replace_slice"></a> `list_replace_slice`





## <a name="list_reverse"></a> `list_reverse`





## <a name="list_select"></a> `list_select`

 uses the selector on each element of the list




## <a name="list_select_property"></a> `list_select_property`





## <a name="list_set_at"></a> `list_set_at`

 sets the lists value at index to the specified value
 the index is normalized -> negativ indices count down from back of list 




## <a name="list_slice"></a> `list_slice`

 retruns a portion of the list specified.
 negative indices count from back of list 





## <a name="list_sort"></a> `list_sort`

 orders a list by a comparator function




## <a name="list_split"></a> `list_split`





## <a name="list_split_at"></a> `list_split_at`





## <a name="list_swap"></a> `list_swap`

 swaps the element of lst at i with element at index j




## <a name="list_to_map"></a> `list_to_map`





## <a name="list_to_string"></a> `list_to_string`

 Converts a CMake list to a string containing elements separated by spaces




## <a name="list_union"></a> `list_union`

 returns a list containing the unqiue set of all elements
 contained in passed list referencese




## <a name="list_unique"></a> `list_unique`

 takes the passed list and returns only its unique elements
 see cmake's list(REMOVE_DUPLICATES)




## <a name="list_where"></a> `list_where`

 executes a predicate on every item of the list (passed by reference)
 and returns those items for which the predicate holds




## <a name="list_without_range"></a> `list_without_range`

 removes the specifed range from the list
 and returns remaining elements




## <a name="is_range"></a> `is_range`





## <a name="list_range_get"></a> `list_range_get`





## <a name="list_range_indices"></a> `list_range_indices`





## <a name="list_range_partial_write"></a> `list_range_partial_write`





## <a name="list_range_remove"></a> `list_range_remove`





## <a name="list_range_replace"></a> `list_range_replace`





## <a name="list_range_set"></a> `list_range_set`





## <a name="list_range_try_get"></a> `list_range_try_get`





## <a name="range_from_indices"></a> `range_from_indices`





## <a name="range_indices"></a> `range_indices`





## <a name="range_indices_valid"></a> `range_indices_valid`





## <a name="range_instanciate"></a> `range_instanciate`





## <a name="range_parse"></a> `range_parse`





## <a name="range_partial_unpack"></a> `range_partial_unpack`





## <a name="range_simplify"></a> `range_simplify`





## <a name="set_difference"></a> `set_difference`





## <a name="set_isequal"></a> `set_isequal`

 retruns true iff lhs and rhs are the same set (ignoring duplicates)
 the null set is only equal to the null set 
 the order of the set (as implied in being a set) does not matter




## <a name="set_issubset"></a> `set_issubset`

 returns true iff lhs is subset of rhs
 duplicate elements in lhs and rhs are ignored
 the null set is subset of every set including itself
 no other set is subset of the null set
 if rhs contains all elements of lhs then lhs is the subset of rhs




## <a name="structured_list_parse"></a> `structured_list_parse`

 parses a structured list given the structure map
 returning a map which contains all the parsed values




## <a name="list_structure_print_help"></a> `list_structure_print_help`





 


